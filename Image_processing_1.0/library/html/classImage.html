<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>ImageProcessingCemisid: Image Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.4 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">ImageProcessingCemisid&#160;<span id="projectnumber">1.0</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a>  </div>
  <div class="headertitle">
<div class="title">Image Class Reference</div>  </div>
</div>
<div class="contents">
<!-- doxytag: class="Image" -->
<p><code>#include &lt;<a class="el" href="Image_8hpp_source.html">Image.hpp</a>&gt;</code></p>

<p><a href="classImage-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classImage_1_1h.html">h</a></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">arma::mat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classImage.html#adc137bf8699177ff23598709300ab091">Image_load</a> (arma::mat, std::string)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Carga de Imagen pgm a mat.  <a href="#adc137bf8699177ff23598709300ab091"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classImage.html#a58edd1c45b4faeb5f789b0d036d02313">Image</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor de la clase.  <a href="#a58edd1c45b4faeb5f789b0d036d02313"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classImage.html#a2077a16b61e5d7612237c681975b8a1f">Image</a> (arma::mat)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classImage.html#a900a9e62aa5bb9cc3c20c9d824a95ef3">Dimension</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtiene las dimensiones de la matriz.  <a href="#a900a9e62aa5bb9cc3c20c9d824a95ef3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classImage.html#aa86aeeebf3fdc0a1a7d298e6162bca7d">Get_pixel</a> (int, int)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtiene el valor de un pixel.  <a href="#aa86aeeebf3fdc0a1a7d298e6162bca7d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classImage.html#a23162a663c28406dcf254696076ec204">Get_pixels</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Imprime todos los pixeles de la matriz imagen.  <a href="#a23162a663c28406dcf254696076ec204"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">arma::mat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classImage.html#a61630c07f6e608502bb6f7656cb154d7">Gaussian_noise</a> (double)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Aplica Ruido Gaussiano a una matriz.  <a href="#a61630c07f6e608502bb6f7656cb154d7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">arma::mat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classImage.html#a7f129688b13d0d5e75d3c524fcd1e6bb">Lost_pixels_noise</a> (double)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Aplica Perdida de pixeles a una matriz.  <a href="#a7f129688b13d0d5e75d3c524fcd1e6bb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">arma::mat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classImage.html#a05c18284cc5906a249ca055e35f98037">Salt_and_pepper_noise</a> (double)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Aplica Ruido Sal y Pimienta a una matriz.  <a href="#a05c18284cc5906a249ca055e35f98037"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">arma::mat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classImage.html#ac33563552d3b003151122a2070e39540">Impulsive_uniform_noise</a> (double)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Aplica Ruido Impulsivo Uniforme a una matriz.  <a href="#ac33563552d3b003151122a2070e39540"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classImage.html#a3203c7c554c580a3c08755bb43d5b048">SaveImage</a> (arma::mat, std::string)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Guarda la matriz en formato pgm.  <a href="#a3203c7c554c580a3c08755bb43d5b048"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classImage.html#a0a7f491ee408027a11cc0551fb4dedbd">PSNR</a> (arma::mat, arma::mat)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculo del PSNR.  <a href="#a0a7f491ee408027a11cc0551fb4dedbd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classImage.html#ac2bfdd46c739cf12e1a9c19635ee1acc">MAE</a> (arma::mat, arma::mat)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculo del MAE.  <a href="#ac2bfdd46c739cf12e1a9c19635ee1acc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classImage.html#a724ca0afc83c93fa43bccd1802c6bd81">MSE</a> (arma::mat, arma::mat)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculo del MSE.  <a href="#a724ca0afc83c93fa43bccd1802c6bd81"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">arma::mat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classImage.html#ad8b8a074b29c240d791859b2b4f7115a">Filtering</a> (arma::mat, int, int)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Aplica un filtrado usando el promedio o la mediana para remover ruido.  <a href="#ad8b8a074b29c240d791859b2b4f7115a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classImage.html#a150d4add6a8f7e926a7bc32ccf875169">Detection_Face</a> (std::string)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classImage.html#a359478a1e745b5da4ce47105ef0be14a">Four_windows_opencv</a> (const char *, const char *, const char *, const char *, const char *, const char *, const char *, const char *)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Carga cuatro imagenes en una ventana de opencv.  <a href="#a359478a1e745b5da4ce47105ef0be14a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classImage.html#ab88eac57a583bac4fe326477d33d57b0">Two_windows_opencv</a> (const char *, const char *, std::string, std::string)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Carga dos imagenes en una ventana de opencv.  <a href="#ab88eac57a583bac4fe326477d33d57b0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">arma::mat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classImage.html#ae20915262dc4e5f323ab1ee1144e8360">Noise_remover</a> (arma::mat, int)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Aproximación Robusta por bloques No solpados (ventana 8x8)  <a href="#ae20915262dc4e5f323ab1ee1144e8360"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">arma::mat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classImage.html#a8c565bce437181ecac5b042055c23919">Overlap</a> (arma::mat)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Aproximación por bloques solpados (ventana 8x8)  <a href="#a8c565bce437181ecac5b042055c23919"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">arma::mat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classImage.html#ac18f2333604b1fff1c27ba8463fce0c1">Idtc_Robusta</a> (arma::mat, int)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Aproximación Robusta por bloques solpados (ventana 8x8)  <a href="#ac18f2333604b1fff1c27ba8463fce0c1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classImage.html#a9c1e1c0c5b6892b39048d05a592569ad">wmedianf</a> (arma::vec &amp;, arma::vec &amp;)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculo de la mediana.  <a href="#a9c1e1c0c5b6892b39048d05a592569ad"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">arma::mat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classImage.html#a199f777054311b461b04b2a55d6a6697">Diccionary</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Diccionario de la transformada del Coseno.  <a href="#a199f777054311b461b04b2a55d6a6697"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">arma::vec&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classImage.html#aeb0fd8b929c1f0413dd188a849a85c80">Fast_awmr</a> (arma::vec &amp;y, arma::mat &amp;A, int sparsity, int itmax, double beta, double tol, double epsilon, int numcoefperiter, double Kpar)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Funcion necesaria para idt_Robusta()  <a href="#aeb0fd8b929c1f0413dd188a849a85c80"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classImage.html#a0294f63700543e11c0f0da85601c7ae5">~Image</a> ()</td></tr>
<tr><td colspan="2"><h2><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classImage.html#a9cef672ffec8e246ae8c34e8c64b57bf">cols</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classImage.html#a3419545b62d16431c2ecdae5c8c5f91f">rows</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">arma::mat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classImage.html#a9cfb2ad2bdb77e4da2f0cc4fef1f2cbb">matrix</a></td></tr>
</table>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a58edd1c45b4faeb5f789b0d036d02313"></a><!-- doxytag: member="Image::Image" ref="a58edd1c45b4faeb5f789b0d036d02313" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Image::Image </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructor de la clase. </p>
<p>Descripcion: Constructor de la clase <a class="el" href="classImage.html">Image</a> para acceder a sus metodos internos</p>
<dl class="test"><dt><b><a class="el" href="test.html#_test000003">Test:</a></b></dt><dd><a class="el" href="basic__funcions_8cpp.html">basic_funcions.cpp</a> <br/>
 <a class="el" href="classImage.html">Image</a> I; <br/>
 I.Dimension(); </dd></dl>

</div>
</div>
<a class="anchor" id="a2077a16b61e5d7612237c681975b8a1f"></a><!-- doxytag: member="Image::Image" ref="a2077a16b61e5d7612237c681975b8a1f" args="(arma::mat)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Image::Image </td>
          <td>(</td>
          <td class="paramtype">arma::mat&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a0294f63700543e11c0f0da85601c7ae5"></a><!-- doxytag: member="Image::~Image" ref="a0294f63700543e11c0f0da85601c7ae5" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Image::~Image </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a150d4add6a8f7e926a7bc32ccf875169"></a><!-- doxytag: member="Image::Detection_Face" ref="a150d4add6a8f7e926a7bc32ccf875169" args="(std::string)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Image::Detection_Face </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a199f777054311b461b04b2a55d6a6697"></a><!-- doxytag: member="Image::Diccionary" ref="a199f777054311b461b04b2a55d6a6697" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mat Image::Diccionary </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Diccionario de la transformada del Coseno. </p>
<p>Descripcion: Funcion necesaria para idt_Robusta()</p>
<p>Basado en los Articulos:</p>
<p>Ramírez J. y Paredes J. (2014). Robust Sparse Recovery Base On Weighted Median Operator. IEEE International Conference on Acoustic, Speech and Signal Processing (ICASSP). Department of Electrical Engineering, Universidad de Los Andes, Mérida, Venezuela. Doi: 978-1-4799-2893-4/14/$31.00. Recuperado de: <a href="http://www.mirlab.org/conference_papers/International_Conference/ICASSP%202014/papers/p1050-ramirez.pdf">http://www.mirlab.org/conference_papers/International_Conference/ICASSP%202014/papers/p1050-ramirez.pdf</a></p>
<p>Ramírez J. y Paredes J. (2015). Robust Transforms Based on the Weighted Median Operator. IEEE Signal Processing Letters, 22(1), pp. 120 – 124. doi: 10.1109/LSP.2014.2349351. Recuperado de: <a href="http://ieeexplore.ieee.org/document/6880779/">http://ieeexplore.ieee.org/document/6880779/</a> </p>

</div>
</div>
<a class="anchor" id="a900a9e62aa5bb9cc3c20c9d824a95ef3"></a><!-- doxytag: member="Image::Dimension" ref="a900a9e62aa5bb9cc3c20c9d824a95ef3" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Image::Dimension </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Obtiene las dimensiones de la matriz. </p>
<p>Descripcion: Permite obtener la dimension nxn de la matriz.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Retorna la dimension de la imagen nxn. </dd></dl>
<dl class="test"><dt><b><a class="el" href="test.html#_test000006">Test:</a></b></dt><dd><a class="el" href="basic__funcions_8cpp.html">basic_funcions.cpp</a> <br/>
 <a class="el" href="classImage.html">Image</a> I; <br/>
 I.Dimension(); </dd></dl>

</div>
</div>
<a class="anchor" id="aeb0fd8b929c1f0413dd188a849a85c80"></a><!-- doxytag: member="Image::Fast_awmr" ref="aeb0fd8b929c1f0413dd188a849a85c80" args="(arma::vec &amp;y, arma::mat &amp;A, int sparsity, int itmax, double beta, double tol, double epsilon, int numcoefperiter, double Kpar)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vec Image::Fast_awmr </td>
          <td>(</td>
          <td class="paramtype">arma::vec &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">arma::mat &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sparsity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>itmax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>epsilon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numcoefperiter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>Kpar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Funcion necesaria para idt_Robusta() </p>
<p>Basado en los Articulos:</p>
<p>Ramírez J. y Paredes J. (2014). Robust Sparse Recovery Base On Weighted Median Operator. IEEE International Conference on Acoustic, Speech and Signal Processing (ICASSP). Department of Electrical Engineering, Universidad de Los Andes, Mérida, Venezuela. Doi: 978-1-4799-2893-4/14/$31.00. Recuperado de: <a href="http://www.mirlab.org/conference_papers/International_Conference/ICASSP%202014/papers/p1050-ramirez.pdf">http://www.mirlab.org/conference_papers/International_Conference/ICASSP%202014/papers/p1050-ramirez.pdf</a></p>
<p>Ramírez J. y Paredes J. (2015). Robust Transforms Based on the Weighted Median Operator. IEEE Signal Processing Letters, 22(1), pp. 120 – 124. doi: 10.1109/LSP.2014.2349351. Recuperado de: <a href="http://ieeexplore.ieee.org/document/6880779/">http://ieeexplore.ieee.org/document/6880779/</a> </p>

</div>
</div>
<a class="anchor" id="ad8b8a074b29c240d791859b2b4f7115a"></a><!-- doxytag: member="Image::Filtering" ref="ad8b8a074b29c240d791859b2b4f7115a" args="(arma::mat, int, int)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mat Image::Filtering </td>
          <td>(</td>
          <td class="paramtype">arma::mat&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Aplica un filtrado usando el promedio o la mediana para remover ruido. </p>
<p>Descripcion: Permite aplicar un filtrado a una matriz, utilizando el sparse. Se selecciona una ventana de lxl a la cual se le aplica un promedio o la mediana para restaurar la imagen. Se calcula utilizando el tamaño de la ventana l y el pixel central de la ventana, luego se aplica el promedio o mediana de los pixels adyacentes al central.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix</td><td>es la matriz con ruido a la cual se le aplicara el filtrado. </td></tr>
    <tr><td class="paramname">l</td><td>es el tamaño de la ventana </td></tr>
    <tr><td class="paramname">flag</td><td>es la bandera que indica si se efectua el promedio o la mediana. Donde el promedio es igual 0 y la mediana igual a 1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>filt_matrix: Retorna la matriz con el filtrado. </dd></dl>
<dl class="test"><dt><b><a class="el" href="test.html#_test000014">Test:</a></b></dt><dd><a class="el" href="filtering__median_8cpp.html">filtering_median.cpp</a> <a class="el" href="filtering__mean_8cpp.html">filtering_mean.cpp</a> <br/>
 mat matrix; <br/>
 int l = 5; <br/>
 int flag = 0; <br/>
 Filtering(matrix, l, flag); </dd></dl>

</div>
</div>
<a class="anchor" id="a359478a1e745b5da4ce47105ef0be14a"></a><!-- doxytag: member="Image::Four_windows_opencv" ref="a359478a1e745b5da4ce47105ef0be14a" args="(const char *, const char *, const char *, const char *, const char *, const char *, const char *, const char *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Image::Four_windows_opencv </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>imag1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>imag2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>imag3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>imag4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>label1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>label2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>label3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>label4</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Carga cuatro imagenes en una ventana de opencv. </p>
<p>Descripcion: Permite cargar cuatro imagenes en una ventana de opencv</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">imag1</td><td>es la ruta o ubicación de la imagen1 </td></tr>
    <tr><td class="paramname">imag2</td><td>es la ruta o ubicación de la imagen2 ....Imag3 ... Imag4 </td></tr>
    <tr><td class="paramname">label1</td><td>es el nombre de la imagen1 </td></tr>
    <tr><td class="paramname">label2</td><td>es el nombre de la imagen2 ....Imag3 ... Imag4 </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Abre la ventana opencv con cuatro imagenes </dd></dl>
<dl class="test"><dt><b><a class="el" href="test.html#_test000001">Test:</a></b></dt><dd><a class="el" href="main_8cpp.html">main.cpp</a> <br/>
 const char* imag1= "src/Resources/images_salt_and_pepper/lady_256_0_1.pgm"; <br/>
 const char* imag2= "src/Resources/images_salt_and_pepper/lady_256_1.pgm"; <br/>
 const char* imag3= "src/Resources/images_salt_and_pepper/lady_256_10.pgm"; <br/>
 const char* imag4= "src/Resources/images_salt_and_pepper/lady_256_100.pgm"; <br/>
 Four_windows_opencv(imag1, imag2, imag3, imag4, label1, label2, label3, label4); </dd></dl>

</div>
</div>
<a class="anchor" id="a61630c07f6e608502bb6f7656cb154d7"></a><!-- doxytag: member="Image::Gaussian_noise" ref="a61630c07f6e608502bb6f7656cb154d7" args="(double)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mat Image::Gaussian_noise </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>nivel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Aplica Ruido Gaussiano a una matriz. </p>
<p>Descripcion: Permite aplicarle Ruido Gaussiano a una matriz. El Ruido Gaussiano es una matriz de media 0 y con una desviacion estandar variable.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">nivel</td><td>es el nivel de varianza variable <br/>
 <br/>
 Parametros Internos: <br/>
 A es una matriz gaussiana de dimensiones iguales a la matriz y de media 0 y varianza 1 <br/>
 B es una matriz donde se almacena la matriz gaussiana de media 0 y el calculo de una varianza determinada <br/>
 std es la desviacion estandar </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>value: Retorna la matriz con el ruido aplicado </dd></dl>
<dl class="test"><dt><b><a class="el" href="test.html#_test000009">Test:</a></b></dt><dd><a class="el" href="gaussian__noise_8cpp.html">gaussian_noise.cpp</a> <br/>
 int nivel=0.1; <br/>
 Gaussian_noise(nivel1); </dd></dl>

</div>
</div>
<a class="anchor" id="aa86aeeebf3fdc0a1a7d298e6162bca7d"></a><!-- doxytag: member="Image::Get_pixel" ref="aa86aeeebf3fdc0a1a7d298e6162bca7d" args="(int, int)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Image::Get_pixel </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>col</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Obtiene el valor de un pixel. </p>
<p>Descripcion: Permite obtener el valor de un pixel de la matriz de la imagen original</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>es el numero de filas de la matriz </td></tr>
    <tr><td class="paramname">col</td><td>es el numero de columnas de la matriz </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Retorna el valor (value) de un pixel </dd></dl>
<dl class="test"><dt><b><a class="el" href="test.html#_test000007">Test:</a></b></dt><dd><a class="el" href="basic__funcions_8cpp.html">basic_funcions.cpp</a> <br/>
 <a class="el" href="classImage.html">Image</a> I; <br/>
 int row=5; <br/>
 int col=5; <br/>
 I.Get_pixel(row, col); </dd></dl>

</div>
</div>
<a class="anchor" id="a23162a663c28406dcf254696076ec204"></a><!-- doxytag: member="Image::Get_pixels" ref="a23162a663c28406dcf254696076ec204" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Image::Get_pixels </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Imprime todos los pixeles de la matriz imagen. </p>
<p>Descripcion: Permite obtener e imprimir todos los pixeles de la imagen.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>value: Retorna todos los pixeles. </dd></dl>
<dl class="test"><dt><b><a class="el" href="test.html#_test000008">Test:</a></b></dt><dd><a class="el" href="basic__funcions_8cpp.html">basic_funcions.cpp</a> <br/>
 <a class="el" href="classImage.html">Image</a> I; <br/>
 I.Get_pixels(); </dd></dl>

</div>
</div>
<a class="anchor" id="ac18f2333604b1fff1c27ba8463fce0c1"></a><!-- doxytag: member="Image::Idtc_Robusta" ref="ac18f2333604b1fff1c27ba8463fce0c1" args="(arma::mat, int)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mat Image::Idtc_Robusta </td>
          <td>(</td>
          <td class="paramtype">arma::mat&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Aproximación Robusta por bloques solpados (ventana 8x8) </p>
<p>Descripcion: Permite remover ruido mediante el uso de una ventana 8x8 solapado por media (0) y mediana ponderada (1).</p>
<p>Basado en los Articulos:</p>
<p>Ramírez J. y Paredes J. (2014). Robust Sparse Recovery Base On Weighted Median Operator. IEEE International Conference on Acoustic, Speech and Signal Processing (ICASSP). Department of Electrical Engineering, Universidad de Los Andes, Mérida, Venezuela. Doi: 978-1-4799-2893-4/14/$31.00. Recuperado de: <a href="http://www.mirlab.org/conference_papers/International_Conference/ICASSP%202014/papers/p1050-ramirez.pdf">http://www.mirlab.org/conference_papers/International_Conference/ICASSP%202014/papers/p1050-ramirez.pdf</a></p>
<p>Ramírez J. y Paredes J. (2015). Robust Transforms Based on the Weighted Median Operator. IEEE Signal Processing Letters, 22(1), pp. 120 – 124. doi: 10.1109/LSP.2014.2349351. Recuperado de: <a href="http://ieeexplore.ieee.org/document/6880779/">http://ieeexplore.ieee.org/document/6880779/</a></p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix</td><td>es la matriz con ruido. </td></tr>
    <tr><td class="paramname">flag</td><td>es la bandera que indica si se efectua el promedio o la mediana. Donde el promedio es igual 0 y la mediana igual a 1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Retorna la matriz sin ruido. </dd></dl>
<dl class="test"><dt><b><a class="el" href="test.html#_test000020">Test:</a></b></dt><dd><a class="el" href="idtc__Robusta__median_8cpp.html">idtc_Robusta_median.cpp</a> <a class="el" href="idtc__Robusta__mean_8cpp.html">idtc_Robusta_mean.cpp</a> <br/>
 mat matrix; <br/>
 int flag = 0; <br/>
 Idtc_Robusta(matrix, flag); </dd></dl>

</div>
</div>
<a class="anchor" id="adc137bf8699177ff23598709300ab091"></a><!-- doxytag: member="Image::Image_load" ref="adc137bf8699177ff23598709300ab091" args="(arma::mat, std::string)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mat Image::Image_load </td>
          <td>(</td>
          <td class="paramtype">arma::mat&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Carga de Imagen pgm a mat. </p>
<p>Descripcion: Permite cargar la imagen en formato pgm a mat</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix</td><td>es la matriz que contine los pixeles de la imagen. </td></tr>
    <tr><td class="paramname">ruta</td><td>es la ubicacion o localizacion de la imagen. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Retorna si la matriz fue cargada o si hubo problemas en la carga. </dd></dl>
<dl class="test"><dt><b><a class="el" href="test.html#_test000002">Test:</a></b></dt><dd><a class="el" href="basic__funcions_8cpp.html">basic_funcions.cpp</a> <br/>
 mat matrix; <br/>
 string ruta = "src/Resources/images/house.256.pgm"; <br/>
 Image_load(matrix, ruta); </dd></dl>

</div>
</div>
<a class="anchor" id="ac33563552d3b003151122a2070e39540"></a><!-- doxytag: member="Image::Impulsive_uniform_noise" ref="ac33563552d3b003151122a2070e39540" args="(double)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mat Image::Impulsive_uniform_noise </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>nivel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Aplica Ruido Impulsivo Uniforme a una matriz. </p>
<p>Descripcion: Permite aplicarle Ruido Impulsivo Uniforme a una matriz</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">nivel</td><td>es el porcentaje de ruido. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>value: Retorna la matriz con el ruido aplicado. </dd></dl>
<dl class="test"><dt><b><a class="el" href="test.html#_test000012">Test:</a></b></dt><dd><a class="el" href="uniform__impulsive__noise_8cpp.html">uniform_impulsive_noise.cpp</a> <br/>
 double nivel=0.1; <br/>
 Impulsive_uniform_noise(nivel); </dd></dl>

</div>
</div>
<a class="anchor" id="a7f129688b13d0d5e75d3c524fcd1e6bb"></a><!-- doxytag: member="Image::Lost_pixels_noise" ref="a7f129688b13d0d5e75d3c524fcd1e6bb" args="(double)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mat Image::Lost_pixels_noise </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>nivel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Aplica Perdida de pixeles a una matriz. </p>
<p>Descripcion: Permite aplicarle Perdida de Pixeles a una matriz</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">nivel</td><td>es el porcentaje de ruido </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>value: Retorna la matriz con el ruido aplicado </dd></dl>
<dl class="test"><dt><b><a class="el" href="test.html#_test000010">Test:</a></b></dt><dd><a class="el" href="lost__Pixels__noise_8cpp.html">lost_Pixels_noise.cpp</a> <br/>
 double nivel=0.1; <br/>
 Lost_pixels_noise(nivel); </dd></dl>

</div>
</div>
<a class="anchor" id="ac2bfdd46c739cf12e1a9c19635ee1acc"></a><!-- doxytag: member="Image::MAE" ref="ac2bfdd46c739cf12e1a9c19635ee1acc" args="(arma::mat, arma::mat)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Image::MAE </td>
          <td>(</td>
          <td class="paramtype">arma::mat&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">arma::mat&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculo del MAE. </p>
<p>Descripcion: Permite calcular el MAE (Error promedio absoluto) de una imagen con ruido y una imagen filtrada</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix_r</td><td>es la matriz con ruido. </td></tr>
    <tr><td class="paramname">matriz_f</td><td>es la matriz filtrada o recuperada </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Retorna el valor del MAE </dd></dl>
<dl class="test"><dt><b><a class="el" href="test.html#_test000019">Test:</a></b></dt><dd><a class="el" href="filtering__mean_8cpp.html">filtering_mean.cpp</a> <br/>
 mat matrix_r; <br/>
 mat matriz_f; <br/>
 MAE(matrix_r, matriz_f); </dd></dl>

</div>
</div>
<a class="anchor" id="a724ca0afc83c93fa43bccd1802c6bd81"></a><!-- doxytag: member="Image::MSE" ref="a724ca0afc83c93fa43bccd1802c6bd81" args="(arma::mat, arma::mat)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Image::MSE </td>
          <td>(</td>
          <td class="paramtype">arma::mat&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">arma::mat&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculo del MSE. </p>
<p>Descripcion: Permite calcular el MSE (Error cuadratico medio) de una imagen con ruido y una imagen filtrada</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix_r</td><td>es la matriz con ruido. </td></tr>
    <tr><td class="paramname">matriz_f</td><td>es la matriz filtrada o recuperada </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Retorna el valor del MSE </dd></dl>
<dl class="test"><dt><b><a class="el" href="test.html#_test000018">Test:</a></b></dt><dd><a class="el" href="filtering__mean_8cpp.html">filtering_mean.cpp</a> <br/>
 mat matrix_r; <br/>
 mat matriz_f; <br/>
 MSE(matrix_r, matriz_f); </dd></dl>

</div>
</div>
<a class="anchor" id="ae20915262dc4e5f323ab1ee1144e8360"></a><!-- doxytag: member="Image::Noise_remover" ref="ae20915262dc4e5f323ab1ee1144e8360" args="(arma::mat, int)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mat Image::Noise_remover </td>
          <td>(</td>
          <td class="paramtype">arma::mat&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Aproximación Robusta por bloques No solpados (ventana 8x8) </p>
<p>Descripcion: Permite remover ruido mediante el uso de una ventana 8x8 no solapado</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix</td><td>es la matriz que se le removerá el ruido. </td></tr>
    <tr><td class="paramname">image_tam</td><td>es el tamaño de la imagen. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>removermatrix: Retorna la matriz sin ruido. </dd></dl>
<dl class="test"><dt><b><a class="el" href="test.html#_test000015">Test:</a></b></dt><dd><a class="el" href="noise__remover_8cpp.html">noise_remover.cpp</a> <br/>
 mat matrix; <br/>
 int image_tam = 256; <br/>
 Noise_remover(matrix, image_tam); </dd></dl>

</div>
</div>
<a class="anchor" id="a8c565bce437181ecac5b042055c23919"></a><!-- doxytag: member="Image::Overlap" ref="a8c565bce437181ecac5b042055c23919" args="(arma::mat)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mat Image::Overlap </td>
          <td>(</td>
          <td class="paramtype">arma::mat&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Aproximación por bloques solpados (ventana 8x8) </p>
<p>Descripcion: Permite remover ruido mediante el uso de una ventana 8x8 solapado</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix</td><td>es la matriz que se le removerá el ruido. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>removermatrix: Retorna la matriz sin ruido. </dd></dl>
<dl class="test"><dt><b><a class="el" href="test.html#_test000016">Test:</a></b></dt><dd><a class="el" href="overlap_8cpp.html">overlap.cpp</a> <br/>
 mat matrix; <br/>
 Overlap(matrix); </dd></dl>

</div>
</div>
<a class="anchor" id="a0a7f491ee408027a11cc0551fb4dedbd"></a><!-- doxytag: member="Image::PSNR" ref="a0a7f491ee408027a11cc0551fb4dedbd" args="(arma::mat, arma::mat)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Image::PSNR </td>
          <td>(</td>
          <td class="paramtype">arma::mat&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">arma::mat&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculo del PSNR. </p>
<p>Descripcion: Permite calcular el PSNR de una imagen con ruido y una imagen filtrada</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix_r</td><td>es la matriz con ruido. </td></tr>
    <tr><td class="paramname">matriz_f</td><td>es la matriz filtrada o recuperada </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Retorna el valor del PSNR </dd></dl>
<dl class="test"><dt><b><a class="el" href="test.html#_test000017">Test:</a></b></dt><dd><a class="el" href="filtering__mean_8cpp.html">filtering_mean.cpp</a> <br/>
 mat matrix_r; <br/>
 mat matriz_f; <br/>
 PSNR(matrix_r, matriz_f); </dd></dl>

</div>
</div>
<a class="anchor" id="a05c18284cc5906a249ca055e35f98037"></a><!-- doxytag: member="Image::Salt_and_pepper_noise" ref="a05c18284cc5906a249ca055e35f98037" args="(double)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mat Image::Salt_and_pepper_noise </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>nivel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Aplica Ruido Sal y Pimienta a una matriz. </p>
<p>Descripcion: Permite aplicarle Ruido Sal y Pimienta a una matriz</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">nivel</td><td>es el porcentaje de ruido </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Retorna la matriz con el ruido (RG) </dd></dl>
<dl class="test"><dt><b><a class="el" href="test.html#_test000011">Test:</a></b></dt><dd><a class="el" href="salt__pepper_8cpp.html">salt_pepper.cpp</a> <br/>
 double nivel=0.1; <br/>
 Salt_and_pepper_noise(nivel); </dd></dl>

</div>
</div>
<a class="anchor" id="a3203c7c554c580a3c08755bb43d5b048"></a><!-- doxytag: member="Image::SaveImage" ref="a3203c7c554c580a3c08755bb43d5b048" args="(arma::mat, std::string)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Image::SaveImage </td>
          <td>(</td>
          <td class="paramtype">arma::mat&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Guarda la matriz en formato pgm. </p>
<p>Descripcion: Permite guardar una matriz mat en formato pgm</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix</td><td>matriz que contine los pixeles de la imagen. </td></tr>
    <tr><td class="paramname">ruta</td><td>ubicacion o localizacion de la imagen. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Retorna si la matriz fue guardada o si hubo problemas al guardar. </dd></dl>
<dl class="test"><dt><b><a class="el" href="test.html#_test000013">Test:</a></b></dt><dd><a class="el" href="gaussian__noise_8cpp.html">gaussian_noise.cpp</a> <br/>
 mat matrix; <br/>
 string ruta= "src/Resources/images/house.256.pgm"; <br/>
 SaveImage(matrix, ruta); </dd></dl>

</div>
</div>
<a class="anchor" id="ab88eac57a583bac4fe326477d33d57b0"></a><!-- doxytag: member="Image::Two_windows_opencv" ref="ab88eac57a583bac4fe326477d33d57b0" args="(const char *, const char *, std::string, std::string)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Image::Two_windows_opencv </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Carga dos imagenes en una ventana de opencv. </p>
<p>Descripcion: Permite cargar dos imagenes en una ventana de opencv con sus respectivas etiquetas (label).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">imag1</td><td>es la ruta o ubicación de la imagen1. </td></tr>
    <tr><td class="paramname">imag2</td><td>es la ruta o ubicación de la imagen2. </td></tr>
    <tr><td class="paramname">label1</td><td>es el nombre de la imagen1. </td></tr>
    <tr><td class="paramname">label2</td><td>es el nombre de la imagen2. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Abre la ventana opencv con dos imagenes. </dd></dl>
<dl class="test"><dt><b><a class="el" href="test.html#_test000021">Test:</a></b></dt><dd><a class="el" href="main_8cpp.html">main.cpp</a> <br/>
 const char* imag1= "src/Resources/images_salt_and_pepper/lady_256_0_1.pgm"; <br/>
 const char* imag2= "src/Resources/images_salt_and_pepper/lady_256_1.pgm"; <br/>
 string label1 = "Imagen1"; <br/>
 string label2 = "Imagen2"; <br/>
 Two_windows_opencv(imag1, imag2, label1, label2); </dd></dl>

</div>
</div>
<a class="anchor" id="a9c1e1c0c5b6892b39048d05a592569ad"></a><!-- doxytag: member="Image::wmedianf" ref="a9c1e1c0c5b6892b39048d05a592569ad" args="(arma::vec &amp;, arma::vec &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Image::wmedianf </td>
          <td>(</td>
          <td class="paramtype">arma::vec &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">arma::vec &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculo de la mediana. </p>
<p>Descripcion: Funcion necesaria para idt_Robusta()</p>
<p>Basado en los Articulos:</p>
<p>Ramírez J. y Paredes J. (2014). Robust Sparse Recovery Base On Weighted Median Operator. IEEE International Conference on Acoustic, Speech and Signal Processing (ICASSP). Department of Electrical Engineering, Universidad de Los Andes, Mérida, Venezuela. Doi: 978-1-4799-2893-4/14/$31.00. Recuperado de: <a href="http://www.mirlab.org/conference_papers/International_Conference/ICASSP%202014/papers/p1050-ramirez.pdf">http://www.mirlab.org/conference_papers/International_Conference/ICASSP%202014/papers/p1050-ramirez.pdf</a></p>
<p>Ramírez J. y Paredes J. (2015). Robust Transforms Based on the Weighted Median Operator. IEEE Signal Processing Letters, 22(1), pp. 120 – 124. doi: 10.1109/LSP.2014.2349351. Recuperado de: <a href="http://ieeexplore.ieee.org/document/6880779/">http://ieeexplore.ieee.org/document/6880779/</a> </p>

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="a9cef672ffec8e246ae8c34e8c64b57bf"></a><!-- doxytag: member="Image::cols" ref="a9cef672ffec8e246ae8c34e8c64b57bf" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classImage.html#a9cef672ffec8e246ae8c34e8c64b57bf">Image::cols</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a9cfb2ad2bdb77e4da2f0cc4fef1f2cbb"></a><!-- doxytag: member="Image::matrix" ref="a9cfb2ad2bdb77e4da2f0cc4fef1f2cbb" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">arma::mat <a class="el" href="classImage.html#a9cfb2ad2bdb77e4da2f0cc4fef1f2cbb">Image::matrix</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a3419545b62d16431c2ecdae5c8c5f91f"></a><!-- doxytag: member="Image::rows" ref="a3419545b62d16431c2ecdae5c8c5f91f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classImage.html#a3419545b62d16431c2ecdae5c8c5f91f">Image::rows</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/<a class="el" href="Image_8hpp_source.html">Image.hpp</a></li>
<li>src/<a class="el" href="Detection__Face__opencv_8cpp.html">Detection_Face_opencv.cpp</a></li>
<li>src/<a class="el" href="Four__windows__opencv_8cpp.html">Four_windows_opencv.cpp</a></li>
<li>src/<a class="el" href="Image__load_8cpp.html">Image_load.cpp</a></li>
<li>src/<a class="el" href="Two__windows__opencv_8cpp.html">Two_windows_opencv.cpp</a></li>
</ul>
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated on Sat Jun 10 2017 16:10:58 for ImageProcessingCemisid by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
